# 							学习笔记·第一周

##### 感想：

​		第一次如此认真的开始系统性的学习数据结构与算法，以前大学时讲数据结构时都没怎么认真听课。。。以前总感觉算法和数据结构是比较高深难懂的东西，一直没敢主动去深入了解，怕被难住而退却。。。如今跟着课程一步步走下来，才发现原来这些并没有想象中难。经过几天的算法题目锻炼后也开始感觉逐渐上道了，虽然目前水平只能做些easy级的题目，不过这次不再恐惧，对未来的学习道路充满信心，希望自己能保持做题的习惯，坚持下去，早日攻克尽量多medium甚至是hard级的题目。

##### 总结：

###### 时间复杂度和空间复杂度

​	一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量，这两点便是指时间复杂度和空间复杂度。我们一般用“大O符号表示法”来表示时间(空间)复杂度：T(n) = O(f(n))。

​	时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。

​	常见的时间复杂度有：常数阶O(1), 对数阶O(logn), 线性阶O(n), 线性对数阶O(n logn), 平方阶O(n^2)，立方阶O(n^3)，k次方阶O(n^K),指数阶O(2^n)等。
​	随着n的不断增大，时间复杂度不断增大，算法花费时间越多。

​	空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。

​	常见的空间复杂度有：常数阶O(1), 对数阶O(logn), 线性阶O(n), 线性对数阶O(n logn), 平方阶O(n^2)等。

###### 数据结构 

主要分为两大类，物理结构和逻辑结构

其中物理结构 为 顺序存储结构-数组 和 链式存储结构-链表。

逻辑结构是抽象的概念，它依赖于物理结构而存在，逻辑结构又可以分为线性结构和非线性结构两种；线性结构如 顺序表、栈和队列；非线性结构如树、图。

------

###### 数组

最常用的数据结构，在物理上表现为连续的存储块，特点是查找快O(1)，操作慢O(n)。

> 之前遍历字符串和数字时，总喜欢将其以字符串的形式split分割成数组，再迭代操作，数字还需要加一个字符串转数字的操作，加上Integer-int之间的装修拆箱操作，这样不仅耗空间，也特别耗时。建议遍历字符串改用toCharArray方法，单个字符比包含单个字符的字符串节省空间，比如'a'占一个字节，"a"占两个字节，因为每个字符串尾自动加一个'＼0'作为字符串结束标志；遍历数字则使用/10的方式分别求出余数即可。

###### 链表

链表不需要连续的存储块空间进行存储，由一系列节点组成，每个节点会存储当前节点的值和下一个节点的位置（双向链表多存储了上一个节点的位置），由于要存储其他节点的位置信息，所以在存储相同数据量的数据时，链表结构会比数组结构更耗费空间。特点是操作快O(1)，查找慢O(n)。

###### 跳表

跳表，是基于链表实现的一种类似“二分”的算法，链表加多级索引的结构，就叫做跳表。它可以快速的实现增，删，改，查操作。

跳表的 查询/更新 时间复杂度可以达到O(logn)。

![image-20200418215948629](C:\Users\William\AppData\Roaming\Typora\typora-user-images\image-20200418215948629.png)

###### 栈

栈(stack)作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。先进后出。

> 一般递归算法都可以用栈的形式替换。

###### 队列

队列(queue)是一种特殊的线性表，特殊之处在于它只允许在表的前端(front)进行删除操作，而在表的后端(rear)进行插入操作，和栈一样，队列是一种操作受限制的线性表。

优先队列 (priority queue) 在队列的基础上加上排序的功能来调整数据的顺序，默认以自然顺序排序，也可以自定义比较器排序。

双端队列 (deque，全名double-ended queue)是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。

------

- 用add first或add last这套新的API改写Deque的代码

  ```java
  Deque<String> deque = new LinkedList<String>();
  deque.add("a");
  deque.addFirst("b");
  deque.addLast("c");
  System.out.println("deque: " + deque);
  String peek = deque.peek();
  System.out.println("peek: " + peek);
  System.out.println("deque: " + deque);
  System.out.println("first: " + deque.getFirst());
  System.out.println("last: " + deque.getLast());
  while (deque.size()>0){
      System.out.println("pop: " + deque.pop());
  }
  System.out.println("deque: " + deque);
  ```

   结果：![image-20200418222541221](C:\Users\William\AppData\Roaming\Typora\typora-user-images\image-20200418222541221.png)

- 分析Queue和Priority Queue的源码

  现阶段的水平剖析源码略有压力，暂时借用网上大佬的：https://www.jianshu.com/p/8f8c15d57f6

  **add()和offer()**
  add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后者则会返回false。对于PriorityQueue这两个方法其实没什么差别。新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。调整的过程为：从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x >= queue[parent]为止。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。

  **element()和peek()**
  element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。

  **remove()和poll()**
  remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。其中的重点siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。

  **remove(Object o)**
  remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。
  
  ------
  
  算法题解题思路后续补上...